<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TSLA Intraday Candles</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <style>
    :root {
      --ink: #101418;
      --muted: #5b6b7a;
      --accent: #e04c4c;
      --accent-2: #1b8b8b;
      --panel: rgba(255, 255, 255, 0.85);
      --shadow: rgba(16, 20, 24, 0.12);
      --bg-1: #f6f0e6;
      --bg-2: #dfe7ef;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Space Grotesk", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(1200px 600px at 10% 0%, #fef6d8 0%, transparent 60%),
        radial-gradient(900px 500px at 90% 10%, #d5f2ff 0%, transparent 55%),
        linear-gradient(180deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
      padding: 32px;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 24px;
    }

    h1 {
      font-family: "DM Serif Display", serif;
      font-size: clamp(28px, 3vw, 40px);
      margin: 0;
      letter-spacing: 0.3px;
    }

    .subtitle {
      color: var(--muted);
      font-size: 15px;
      max-width: 640px;
    }

    .panel {
      background: var(--panel);
      border-radius: 16px;
      box-shadow: 0 12px 30px var(--shadow);
      padding: 20px;
      backdrop-filter: blur(8px);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      align-items: end;
    }

    label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-bottom: 6px;
      display: block;
    }

    input, select, button {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(16, 20, 24, 0.1);
      font-family: inherit;
      font-size: 14px;
      background: #fff;
      color: var(--ink);
    }

    button {
      cursor: pointer;
      background: var(--accent);
      color: #fff;
      border: none;
      font-weight: 600;
      transition: transform 120ms ease, box-shadow 120ms ease;
      box-shadow: 0 10px 18px rgba(224, 76, 76, 0.25);
    }

    button:hover {
      transform: translateY(-1px);
    }

    #status {
      margin-top: 12px;
      font-size: 13px;
      color: var(--muted);
    }

    #chart {
      margin-top: 24px;
      height: 520px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-2);
    }

    .live-price {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(16, 20, 24, 0.08);
      background: rgba(255, 255, 255, 0.6);
      margin-bottom: 16px;
    }

    .live-label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .live-quote {
      display: flex;
      align-items: baseline;
      gap: 10px;
      font-size: clamp(24px, 3vw, 32px);
      font-weight: 600;
    }

    .live-change {
      font-size: 14px;
      font-weight: 600;
    }

    .live-open {
      font-size: 13px;
      color: var(--muted);
    }

    .live-updated {
      font-size: 12px;
      margin-top: 4px;
    }

    .change-positive {
      color: var(--accent-2);
    }

    .change-negative {
      color: var(--accent);
    }

    .change-neutral {
      color: var(--muted);
    }

    .info-panel {
      margin-top: 24px;
    }

    .info-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
      margin-bottom: 12px;
    }

    .info-title {
      font-weight: 600;
      font-size: 16px;
    }

    .info-updated {
      font-size: 12px;
      color: var(--muted);
    }

    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px 18px;
    }

    .info-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
      color: var(--muted);
    }

    .info-item strong {
      color: var(--ink);
      font-size: 15px;
      font-weight: 600;
    }

    .details-panel {
      margin-top: 24px;
    }

    .details-status {
      margin-bottom: 12px;
      font-size: 13px;
      color: var(--muted);
    }

    .details-stack {
      display: grid;
      gap: 12px;
    }

    .detail-box {
      border: 1px solid rgba(16, 20, 24, 0.1);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.55);
      overflow: hidden;
    }

    .detail-header {
      padding: 12px 14px;
      font-weight: 600;
      font-size: 14px;
      border-bottom: 1px solid rgba(16, 20, 24, 0.08);
      background: rgba(255, 255, 255, 0.4);
    }

    .detail-content {
      padding: 12px;
    }

    .detail-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px 16px;
    }

    .detail-kv {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
      min-width: 0;
    }

    .detail-kv strong {
      color: var(--ink);
      font-size: 14px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .detail-text {
      font-size: 13px;
      color: var(--ink);
      line-height: 1.5;
      margin-top: 8px;
    }

    .chip-wrap {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .chip {
      border: 1px solid rgba(16, 20, 24, 0.12);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      color: var(--ink);
      background: rgba(255, 255, 255, 0.8);
    }

    .detail-table-wrap {
      overflow-x: auto;
      margin-top: 8px;
    }

    .detail-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 520px;
      font-size: 12px;
      table-layout: fixed;
    }

    .detail-table th {
      text-align: left;
      color: var(--muted);
      font-weight: 600;
      padding: 8px;
      border-bottom: 1px solid rgba(16, 20, 24, 0.12);
      white-space: nowrap;
    }

    .detail-table td {
      padding: 8px;
      border-bottom: 1px solid rgba(16, 20, 24, 0.08);
      color: var(--ink);
      vertical-align: top;
      white-space: normal;
      word-break: break-word;
    }

    .muted {
      color: var(--muted);
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 10px;
      margin-top: 8px;
      margin-bottom: 8px;
    }

    .summary-card {
      border: 1px solid rgba(16, 20, 24, 0.1);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px 12px;
    }

    .summary-card .label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .summary-card .value {
      margin-top: 6px;
      font-size: 17px;
      font-weight: 600;
      color: var(--ink);
    }

    .mini-chart {
      margin-top: 8px;
      border: 1px solid rgba(16, 20, 24, 0.08);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.75);
      padding: 10px;
    }

    .mini-chart-title {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .bar-row {
      display: grid;
      grid-template-columns: 74px 1fr 90px;
      gap: 8px;
      align-items: center;
      margin-bottom: 6px;
    }

    .bar-label {
      font-size: 11px;
      color: var(--muted);
    }

    .bar-track {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(16, 20, 24, 0.08);
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      border-radius: 999px;
      background: linear-gradient(90deg, #1b8b8b, #4db6a6);
    }

    .bar-value {
      font-size: 11px;
      color: var(--ink);
      text-align: right;
    }

    @media (max-width: 720px) {
      body {
        padding: 20px;
      }

      #chart {
        height: 420px;
      }
    }
  </style>
</head>
<body>
  <header>

  </header>

  <div class="panel">
    <div id="controls" class="controls">
      <div>
        <label for="symbol">Symbol</label>
        <select id="symbol">
          <option value="">Loading symbols...</option>
        </select>
      </div>
      <div>
        <label for="date">Date (ET)</label>
        <input id="date" type="text" />
      </div>
      <div>
        <label for="range">Range</label>
        <select id="range">
          <option value="1d">1 day</option>
          <option value="5d">5 days</option>
          <option value="1m">1 month</option>
        </select>
      </div>
    </div>
    <div class="live-price">
      <div>
        <div id="live-symbol-label" class="live-label">TSLA live price</div>
        <div class="live-quote">
          <span id="live-price">-</span>
          <span id="live-change" class="live-change change-neutral">-</span>
        </div>
        <div class="live-open">Open: <span id="live-open">-</span></div>
        <div id="live-updated" class="live-updated change-neutral">Updated -</div>
      </div>
    </div>
    <div id="status" class="badge"><span class="dot"></span><span>Ready</span></div>
  </div>

  <div id="chart" class="panel"></div>
  <div id="stock-info" class="panel info-panel">
    <div class="info-header">
      <div class="info-title">Stock information</div>
      <div id="info-updated" class="info-updated">Updated -</div>
    </div>
    <div class="info-grid">
      <!-- information provided -->
      <div class="info-item"><span>Previous close</span><strong id="info-prev-close">-</strong></div>
      <div class="info-item"><span>Open</span><strong id="info-open">-</strong></div>
      <div class="info-item"><span>Day range</span><strong id="info-day-range">-</strong></div>
      <div class="info-item"><span>52-week range</span><strong id="info-year-range">-</strong></div>
      <div class="info-item"><span>Volume</span><strong id="info-volume">-</strong></div>
      <div class="info-item"><span>Market cap</span><strong id="info-market-cap">-</strong></div>
      <div class="info-item"><span>Bid / Ask</span><strong id="info-bid-ask">-</strong></div>
    </div>
  </div>
  <div id="market-details" class="panel details-panel">
    <div class="info-header">
      <div class="info-title">Market details</div>
      <div id="details-updated" class="info-updated">Updated -</div>
    </div>
    <div id="details-status" class="details-status">Ready</div>
    <div id="details-body" class="details-stack"></div>
  </div>
  

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
  
  <script>
    const statusEl = document.getElementById("status");
    const statusText = statusEl.querySelector("span:last-child");
    const form = document.getElementById("controls");
    const symbolInput = document.getElementById("symbol");
    const dateInput = document.getElementById("date");
    const rangeInput = document.getElementById("range");
    const chartEl = document.getElementById("chart");
    // JSDOM
    const liveSymbolLabel = document.getElementById("live-symbol-label");
    const livePriceEl = document.getElementById("live-price");
    const liveChangeEl = document.getElementById("live-change");
    const liveOpenEl = document.getElementById("live-open");
    const liveUpdatedEl = document.getElementById("live-updated");
    const infoUpdatedEl = document.getElementById("info-updated");
    const infoPrevCloseEl = document.getElementById("info-prev-close");
    const infoOpenEl = document.getElementById("info-open");
    const infoDayRangeEl = document.getElementById("info-day-range");
    const infoYearRangeEl = document.getElementById("info-year-range");
    const infoVolumeEl = document.getElementById("info-volume");
    const infoMarketCapEl = document.getElementById("info-market-cap");
    const infoBidAskEl = document.getElementById("info-bid-ask");
    const detailsUpdatedEl = document.getElementById("details-updated");
    const detailsStatusEl = document.getElementById("details-status");
    const detailsBodyEl = document.getElementById("details-body");

    const CHANGE_CLASSES = ["change-positive", "change-negative", "change-neutral"];
    let liveSymbol = "TSLA";
    let liveOpenPrice;
    let lastLiveUpdate;
    let livePoller;
    let liveTicker;
    let livePollingEnabled = false;
    let latestStockInfo;
    let latestMarketDetails;

    function setStatus(text, tone = "neutral") {
      statusText.textContent = text;
      const dot = statusEl.querySelector(".dot");
      if (tone === "error") {
        dot.style.background = "#e04c4c";
      } else {
        dot.style.background = "#1b8b8b";
      }
    }

    function applyChangeClass(el, direction) {
      for (let i = 0; i < CHANGE_CLASSES.length; i++) {
        const cls = CHANGE_CLASSES[i];
        el.classList.remove(cls);
      }
      if (direction > 0) {
        el.classList.add("change-positive");
      } else if (direction < 0) {
        el.classList.add("change-negative");
      } else {
        el.classList.add("change-neutral");
      }
    }

    function formatPrice(value) {
      return `$${value.toFixed(2)}`;
    }

    function formatNumber(value, digits = 2) {
      return Number(value).toFixed(digits);
    }

    function formatInt(value) {
      return Math.round(Number(value)).toLocaleString("en-US");
    }

    function formatCompact(value) {
      const n = Number(value);
      if (!Number.isFinite(n)) {
        return "-";
      }
      return new Intl.NumberFormat("en-US", {
        notation: "compact",
        maximumFractionDigits: 2,
      }).format(n);
    }

    function formatNullable(value, formatter) {
      const n = Number(value);
      if (!Number.isFinite(n)) {
        return "-";
      }
      if (formatter) {
        return formatter(n);
      }
      return n.toLocaleString("en-US");
    }

    function formatDateText(value) {
      const text = String(value || "");
      if (!text) {
        return "-";
      }
      return text;
    }

    function escapeHtml(value) {
      return String(value || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function formatRange(low, high) {
      const left = formatNullable(low, formatPrice);
      const right = formatNullable(high, formatPrice);
      if (left === "-" && right === "-") {
        return "-";
      }
      return `${left} - ${right}`;
    }

    function makeKvGrid(items) {
      const rows = [];
      for (let i = 0; i < items.length; i += 1) {
        const item = items[i];
        const label = escapeHtml(item.label);
        const value = escapeHtml(item.value);
        rows.push(`<div class="detail-kv"><span>${label}</span><strong>${value}</strong></div>`);
      }
      return `<div class="detail-grid">${rows.join("")}</div>`;
    }

    function makeTable(columns, rows) {
      if (!Array.isArray(rows) || rows.length === 0) {
        return "";
      }
      const header = columns.map((col) => `<th>${escapeHtml(col.label)}</th>`).join("");
      const body = rows.map((row) => {
        const cells = columns.map((col) => {
          const raw = row[col.key];
          const val = col.formatter ? col.formatter(raw, row) : raw;
          if (col.rawHtml === true) {
            return `<td>${val}</td>`;
          }
          return `<td>${escapeHtml(val)}</td>`;
        }).join("");
        return `<tr>${cells}</tr>`;
      }).join("");
      return `<div class="detail-table-wrap"><table class="detail-table"><thead><tr>${header}</tr></thead><tbody>${body}</tbody></table></div>`;
    }

    function buildDetailSection(title, contentHtml) {
      return `<div class="detail-box"><div class="detail-header">${escapeHtml(title)}</div><div class="detail-content">${contentHtml}</div></div>`;
    }

    function makeSummaryCards(items) {
      if (!Array.isArray(items) || items.length === 0) {
        return "";
      }
      const cards = [];
      for (let i = 0; i < items.length; i += 1) {
        const item = items[i];
        cards.push(
          `<div class="summary-card"><div class="label">${escapeHtml(item.label)}</div><div class="value">${escapeHtml(item.value)}</div></div>`
        );
      }
      return `<div class="summary-grid">${cards.join("")}</div>`;
    }

    function makeMiniBarChart(title, rows) {
      if (!Array.isArray(rows) || rows.length === 0) {
        return "";
      }
      let maxValue = 0;
      for (let i = 0; i < rows.length; i += 1) {
        const n = Number(rows[i].value);
        if (Number.isFinite(n) && n > maxValue) {
          maxValue = n;
        }
      }
      if (!(maxValue > 0)) {
        return "";
      }
      const body = [];
      for (let i = 0; i < rows.length; i += 1) {
        const row = rows[i];
        const value = Number(row.value);
        if (!Number.isFinite(value) || value <= 0) {
          continue;
        }
        const pct = Math.max(2, Math.min(100, (value / maxValue) * 100));
        body.push(
          `<div class="bar-row"><div class="bar-label">${escapeHtml(row.label)}</div><div class="bar-track"><div class="bar-fill" style="width:${pct}%"></div></div><div class="bar-value">${escapeHtml(row.display)}</div></div>`
        );
      }
      if (body.length === 0) {
        return "";
      }
      return `<div class="mini-chart"><div class="mini-chart-title">${escapeHtml(title)}</div>${body.join("")}</div>`;
    }

    async function fetchJsonWithTimeout(url, timeoutMs = 6000) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const res = await fetch(url, { signal: controller.signal });
        let data = {};
        try {
          data = await res.json();
        } catch {
          data = {};
        }
        return { ok: res.ok, data };
      } catch {
        return { ok: false, data: {} };
      } finally {
        clearTimeout(timer);
      }
    }

    function renderMarketDetails(payload) {
      latestMarketDetails = payload;
      const sections = payload && payload.sections ? payload.sections : {};
      const overview = sections.overview || {};
      const company = sections.company || {};
      const people = sections.people || {};
      const financial = sections.financial || {};
      const analysis = sections.analysis || {};
      const news = Array.isArray(sections.news) ? sections.news : [];
      const insider = Array.isArray(sections.insider) ? sections.insider : [];

      const blocks = [];

      const overviewItems = [
        { label: "Company", value: overview.name || "-" },
        { label: "Exchange", value: overview.exchange || "-" },
        { label: "Sector", value: overview.sector || "-" },
        { label: "Industry", value: overview.industry || "-" },
        { label: "CEO", value: overview.ceo || "-" },
        { label: "Country", value: overview.country || "-" },
        { label: "IPO date", value: formatDateText(overview.ipoDate) },
        { label: "Price", value: formatNullable(overview.price, formatPrice) },
        { label: "Previous close", value: formatNullable(overview.previousClose, formatPrice) },
        { label: "Open", value: formatNullable(overview.open, formatPrice) },
        { label: "Day low", value: formatNullable(overview.dayLow, formatPrice) },
        { label: "Day high", value: formatNullable(overview.dayHigh, formatPrice) },
        { label: "52-week low", value: formatNullable(overview.yearLow, formatPrice) },
        { label: "52-week high", value: formatNullable(overview.yearHigh, formatPrice) },
        { label: "Volume", value: formatNullable(overview.volume, formatInt) },
      ];
      let overviewHtml = makeKvGrid(overviewItems);
      if (overview.description) {
        overviewHtml += `<div class="detail-text">${escapeHtml(overview.description)}</div>`;
      }
      if (overview.website) {
        const safeUrl = escapeHtml(overview.website);
        overviewHtml += `<div class="detail-text">Website: <a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${safeUrl}</a></div>`;
      }
      blocks.push(buildDetailSection("Overview", overviewHtml));

      const companyItems = [
        { label: "Phone", value: company.phone || "-" },
        { label: "ISIN", value: company.isin || "-" },
        { label: "CUSIP", value: company.cusip || "-" },
        { label: "Screener exchange", value: company.screener && company.screener.exchangeShortName ? company.screener.exchangeShortName : "-" },
        { label: "Screener country", value: company.screener && company.screener.country ? company.screener.country : "-" },
      ];
      let companyHtml = makeKvGrid(companyItems);
      if (Array.isArray(company.searchExchangeVariants) && company.searchExchangeVariants.length) {
        companyHtml += makeTable(
          [
            { key: "symbol", label: "Symbol", formatter: (v) => v || "-" },
            { key: "exchangeShortName", label: "Exchange", formatter: (v) => v || "-" },
          ],
          company.searchExchangeVariants
        );
      }
      blocks.push(buildDetailSection("Company", companyHtml));

      const keyExecRows = (Array.isArray(people.keyExecutives) ? people.keyExecutives : []).filter((row) => {
        const pay = Number(row && row.pay);
        return Number.isFinite(pay) && pay > 0;
      });
      const peopleHtml = makeTable(
        [
          { key: "name", label: "Name", formatter: (v) => v || "-" },
          { key: "title", label: "Title", formatter: (v) => v || "-" },
          { key: "pay", label: "Pay", formatter: (v) => formatNullable(v, formatCompact) },
        ],
        keyExecRows
      );
      if (peopleHtml) {
        blocks.push(buildDetailSection("People", peopleHtml));
      }

      const ttmRatios = financial.ratiosTtm || {};
      let financialHtml = makeKvGrid([
        { label: "Current ratio", value: formatNullable(ttmRatios.currentRatioTTM || ttmRatios.currentRatio, (n) => n.toFixed(2)) },
        { label: "Quick ratio", value: formatNullable(ttmRatios.quickRatioTTM || ttmRatios.quickRatio, (n) => n.toFixed(2)) },
        { label: "Net margin", value: formatNullable(ttmRatios.netProfitMarginTTM || ttmRatios.netProfitMargin, (n) => `${n.toFixed(2)}%`) },
        { label: "Float shares", value: formatNullable(financial.sharesFloat && financial.sharesFloat.floatShares, formatInt) },
        { label: "Outstanding", value: formatNullable(financial.sharesFloat && financial.sharesFloat.outstandingShares, formatInt) },
      ]);
      financialHtml += makeTable(
        [
          { key: "date", label: "Date", formatter: (v) => formatDateText(v) },
          { key: "totalAssets", label: "Assets", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "totalLiabilities", label: "Liabilities", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "totalStockholdersEquity", label: "Equity", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "totalDebt", label: "Debt", formatter: (v) => formatNullable(v, formatCompact) },
        ],
        Array.isArray(financial.balanceSheet) ? financial.balanceSheet : []
      );
      financialHtml += makeTable(
        [
          { key: "date", label: "Date", formatter: (v) => formatDateText(v) },
          { key: "currentRatio", label: "Current ratio", formatter: (v) => formatNullable(v, (n) => n.toFixed(2)) },
          { key: "quickRatio", label: "Quick ratio", formatter: (v) => formatNullable(v, (n) => n.toFixed(2)) },
          { key: "netProfitMargin", label: "Net margin", formatter: (v) => formatNullable(v, (n) => `${n.toFixed(2)}%`) },
        ],
        Array.isArray(financial.ratios) ? financial.ratios : []
      );
      financialHtml += makeTable(
        [
          { key: "date", label: "Date", formatter: (v) => formatDateText(v) },
          { key: "enterpriseValue", label: "Enterprise value", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "numberOfShares", label: "Shares", formatter: (v) => formatNullable(v, formatInt) },
        ],
        Array.isArray(financial.enterpriseValues) ? financial.enterpriseValues : []
      );
      const incomeQuarterRows = Array.isArray(financial.incomeStatementQuarterly) ? financial.incomeStatementQuarterly : [];
      const cashQuarterRows = Array.isArray(financial.cashFlowStatementQuarterly) ? financial.cashFlowStatementQuarterly : [];
      const balanceQuarterRows = Array.isArray(financial.balanceSheetQuarterly) ? financial.balanceSheetQuarterly : [];
      financialHtml += makeTable(
        [
          { key: "date", label: "Quarter", formatter: (v) => formatDateText(v) },
          { key: "revenue", label: "Revenue", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "netIncome", label: "Net income", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "ebitda", label: "EBITDA", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "eps", label: "EPS", formatter: (v) => formatNullable(v, (n) => n.toFixed(2)) },
        ],
        incomeQuarterRows
      );
      financialHtml += makeTable(
        [
          { key: "date", label: "Quarter", formatter: (v) => formatDateText(v) },
          { key: "operatingCashFlow", label: "Operating CF", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "freeCashFlow", label: "Free CF", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "capitalExpenditure", label: "CapEx", formatter: (v) => formatNullable(v, formatCompact) },
        ],
        cashQuarterRows
      );
      const revenueTrendRows = [];
      for (let i = 0; i < Math.min(8, incomeQuarterRows.length); i += 1) {
        const row = incomeQuarterRows[i];
        const value = Number(row.revenue);
        if (Number.isFinite(value) && value > 0) {
          revenueTrendRows.push({
            label: String(row.date || "").slice(0, 7),
            value,
            display: formatCompact(value),
          });
        }
      }
      financialHtml += makeMiniBarChart("Quarterly revenue trend", revenueTrendRows);
      const netIncomeTrendRows = [];
      for (let i = 0; i < Math.min(8, incomeQuarterRows.length); i += 1) {
        const row = incomeQuarterRows[i];
        const value = Number(row.netIncome);
        if (Number.isFinite(value) && value > 0) {
          netIncomeTrendRows.push({
            label: String(row.date || "").slice(0, 7),
            value,
            display: formatCompact(value),
          });
        }
      }
      financialHtml += makeMiniBarChart("Quarterly net income trend", netIncomeTrendRows);
      const opCfTrendRows = [];
      for (let i = 0; i < Math.min(8, cashQuarterRows.length); i += 1) {
        const row = cashQuarterRows[i];
        const value = Number(row.operatingCashFlow);
        if (Number.isFinite(value) && value > 0) {
          opCfTrendRows.push({
            label: String(row.date || "").slice(0, 7),
            value,
            display: formatCompact(value),
          });
        }
      }
      financialHtml += makeMiniBarChart("Quarterly operating cashflow trend", opCfTrendRows);
      const freeCfTrendRows = [];
      for (let i = 0; i < Math.min(8, cashQuarterRows.length); i += 1) {
        const row = cashQuarterRows[i];
        const value = Number(row.freeCashFlow);
        if (Number.isFinite(value) && value > 0) {
          freeCfTrendRows.push({
            label: String(row.date || "").slice(0, 7),
            value,
            display: formatCompact(value),
          });
        }
      }
      financialHtml += makeMiniBarChart("Quarterly free cashflow trend", freeCfTrendRows);
      const assetsTrendRows = [];
      for (let i = 0; i < Math.min(8, balanceQuarterRows.length); i += 1) {
        const row = balanceQuarterRows[i];
        const value = Number(row.totalAssets);
        if (Number.isFinite(value) && value > 0) {
          assetsTrendRows.push({
            label: String(row.date || "").slice(0, 7),
            value,
            display: formatCompact(value),
          });
        }
      }
      financialHtml += makeMiniBarChart("Quarterly assets trend", assetsTrendRows);
      const liabilitiesTrendRows = [];
      for (let i = 0; i < Math.min(8, balanceQuarterRows.length); i += 1) {
        const row = balanceQuarterRows[i];
        const value = Number(row.totalLiabilities);
        if (Number.isFinite(value) && value > 0) {
          liabilitiesTrendRows.push({
            label: String(row.date || "").slice(0, 7),
            value,
            display: formatCompact(value),
          });
        }
      }
      financialHtml += makeMiniBarChart("Quarterly liabilities trend", liabilitiesTrendRows);
      const debtTrendRows = [];
      for (let i = 0; i < Math.min(8, balanceQuarterRows.length); i += 1) {
        const row = balanceQuarterRows[i];
        const value = Number(row.totalDebt);
        if (Number.isFinite(value) && value > 0) {
          debtTrendRows.push({
            label: String(row.date || "").slice(0, 7),
            value,
            display: formatCompact(value),
          });
        }
      }
      financialHtml += makeMiniBarChart("Quarterly debt trend", debtTrendRows);
      blocks.push(buildDetailSection("Financial", financialHtml));

      let analysisHtml = "";
      const estimateRows = Array.isArray(analysis.analystEstimates) ? analysis.analystEstimates : [];
      const gradeRows = Array.isArray(analysis.grades) ? analysis.grades : [];
      const earningsRows = Array.isArray(analysis.earningsSurprises) ? analysis.earningsSurprises : [];
      const priceTargetRows = Array.isArray(analysis.priceTargetHistory) ? analysis.priceTargetHistory : [];
      let upgrades = 0;
      let downgrades = 0;
      let reiterates = 0;
      for (let i = 0; i < gradeRows.length; i += 1) {
        const action = String(gradeRows[i].action || "").toLowerCase();
        if (action.includes("up")) {
          upgrades += 1;
        } else if (action.includes("down")) {
          downgrades += 1;
        } else if (action) {
          reiterates += 1;
        }
      }
      analysisHtml += makeSummaryCards([
        { label: "Upgrades", value: String(upgrades) },
        { label: "Downgrades", value: String(downgrades) },
        { label: "Other actions", value: String(reiterates) },
      ]);
      const estimateTrend = [];
      for (let i = 0; i < Math.min(6, estimateRows.length); i += 1) {
        const row = estimateRows[i];
        const rev = Number(row.estimatedRevenueAvg);
        if (Number.isFinite(rev) && rev > 0) {
          estimateTrend.push({
            label: String(row.date || "").slice(0, 4) || `R${i + 1}`,
            value: rev,
            display: formatCompact(rev),
          });
        }
      }
      analysisHtml += makeMiniBarChart("Revenue estimate trend", estimateTrend);
      const netIncomeTrend = [];
      for (let i = 0; i < Math.min(6, estimateRows.length); i += 1) {
        const row = estimateRows[i];
        const net = Number(row.estimatedNetIncomeAvg);
        if (Number.isFinite(net) && net > 0) {
          netIncomeTrend.push({
            label: String(row.date || "").slice(0, 4) || `N${i + 1}`,
            value: net,
            display: formatCompact(net),
          });
        }
      }
      analysisHtml += makeMiniBarChart("Net income estimate trend", netIncomeTrend);
      const earningsSurpriseTrend = [];
      for (let i = 0; i < Math.min(8, earningsRows.length); i += 1) {
        const row = earningsRows[i];
        const pct = Number(row.surprisePct);
        if (Number.isFinite(pct)) {
          earningsSurpriseTrend.push({
            label: String(row.date || "").slice(0, 7),
            value: Math.abs(pct),
            display: `${pct.toFixed(2)}%`,
          });
        }
      }
      analysisHtml += makeMiniBarChart("Earnings surprise trend", earningsSurpriseTrend);
      analysisHtml += makeTable(
        [
          { key: "date", label: "Date", formatter: (v) => formatDateText(v) },
          { key: "actual", label: "Actual EPS", formatter: (v) => formatNullable(v, (n) => n.toFixed(2)) },
          { key: "estimate", label: "Estimate EPS", formatter: (v) => formatNullable(v, (n) => n.toFixed(2)) },
          { key: "surprisePct", label: "Surprise %", formatter: (v) => formatNullable(v, (n) => `${n.toFixed(2)}%`) },
        ],
        earningsRows
      );
      const priceTargetTrendRows = [];
      for (let i = 0; i < Math.min(8, priceTargetRows.length); i += 1) {
        const row = priceTargetRows[i];
        const target = Number(row.targetPrice);
        if (Number.isFinite(target) && target > 0) {
          priceTargetTrendRows.push({
            label: String(row.date || "").slice(0, 7),
            value: target,
            display: formatPrice(target),
          });
        }
      }
      analysisHtml += makeMiniBarChart("Price target history trend", priceTargetTrendRows);
      analysisHtml += makeTable(
        [
          { key: "date", label: "Date", formatter: (v) => formatDateText(v) },
          { key: "analyst", label: "Analyst", formatter: (v) => v || "-" },
          { key: "targetPrice", label: "Target", formatter: (v) => formatNullable(v, formatPrice) },
          { key: "newsUrl", label: "Source", formatter: (v) => {
            const url = String(v || "").trim();
            if (!url) {
              return "-";
            }
            const safe = escapeHtml(url);
            return `<a href="${safe}" target="_blank" rel="noopener noreferrer">Link</a>`;
          }, rawHtml: true },
        ],
        priceTargetRows
      );
      analysisHtml += makeTable(
        [
          { key: "date", label: "Date", formatter: (v) => formatDateText(v) },
          { key: "estimatedRevenueAvg", label: "Revenue est", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "estimatedNetIncomeAvg", label: "Net income est", formatter: (v) => formatNullable(v, formatCompact) },
          { key: "estimatedEpsAvg", label: "EPS est", formatter: (v) => formatNullable(v, (n) => n.toFixed(2)) },
        ],
        Array.isArray(analysis.analystEstimates) ? analysis.analystEstimates : []
      );
      analysisHtml += makeTable(
        [
          { key: "date", label: "Date", formatter: (v) => formatDateText(v) },
          { key: "gradingCompany", label: "Firm", formatter: (v) => v || "-" },
          { key: "previousGrade", label: "Prev", formatter: (v) => v || "-" },
          { key: "newGrade", label: "New", formatter: (v) => v || "-" },
          { key: "action", label: "Action", formatter: (v) => v || "-" },
        ],
        Array.isArray(analysis.grades) ? analysis.grades : []
      );
      if (analysisHtml) {
        blocks.push(buildDetailSection("Analysis", analysisHtml));
      }

      const newsHtml = makeTable(
        [
          { key: "publishedDate", label: "Date", formatter: (v) => formatDateText(v) },
          { key: "title", label: "Title", formatter: (v, row) => {
            const titleText = escapeHtml(v || "Untitled");
            if (row.url && String(row.url).trim()) {
              const safeUrl = escapeHtml(String(row.url));
              return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${titleText}</a>`;
            }
            return titleText;
          }, rawHtml: true },
        ],
        news.slice(0, 20)
      );
      if (newsHtml) {
        blocks.push(buildDetailSection("News", newsHtml));
      }

      const insiderHtml = makeTable(
        [
          { key: "date", label: "Date", formatter: (v) => formatDateText(v) },
          { key: "reportingName", label: "Reporter", formatter: (v) => v || "-" },
          { key: "transactionType", label: "Type", formatter: (v) => v || "-" },
          { key: "securitiesTransacted", label: "Shares", formatter: (v) => formatNullable(v, formatInt) },
          { key: "price", label: "Price", formatter: (v) => formatNullable(v, formatPrice) },
        ],
        insider.slice(0, 20)
      );
      let insiderBuy = 0;
      let insiderSell = 0;
      let insiderUnknown = 0;
      for (let i = 0; i < insider.length; i += 1) {
        const row = insider[i];
        const qty = Number(row.securitiesTransacted);
        const amount = Number.isFinite(qty) ? Math.abs(qty) : 0;
        const type = String(row.transactionType || "").toLowerCase();
        if (type.includes("buy") || type.includes("acquire") || type.includes("purchase")) {
          insiderBuy += amount;
        } else if (type.includes("sell") || type.includes("dispose") || type.includes("sale")) {
          insiderSell += amount;
        } else {
          insiderUnknown += amount;
        }
      }
      let insiderSectionHtml = "";
      insiderSectionHtml += makeSummaryCards([
        { label: "Insider buys (shares)", value: formatInt(insiderBuy) },
        { label: "Insider sells (shares)", value: formatInt(insiderSell) },
        { label: "Unclassified (shares)", value: formatInt(insiderUnknown) },
      ]);
      insiderSectionHtml += insiderHtml;
      if (insiderSectionHtml) {
        blocks.push(buildDetailSection("Insider activity", insiderSectionHtml));
      }

      const enterpriseRows = Array.isArray(financial.enterpriseValues) ? financial.enterpriseValues : [];
      const enterpriseTrend = [];
      for (let i = 0; i < Math.min(6, enterpriseRows.length); i += 1) {
        const row = enterpriseRows[i];
        const ev = Number(row.enterpriseValue);
        if (Number.isFinite(ev) && ev > 0) {
          enterpriseTrend.push({
            label: String(row.date || "").slice(0, 4) || `E${i + 1}`,
            value: ev,
            display: formatCompact(ev),
          });
        }
      }
      const enterpriseTrendHtml = makeMiniBarChart("Enterprise value trend", enterpriseTrend);
      if (enterpriseTrendHtml) {
        blocks.push(buildDetailSection("Enterprise value trend", enterpriseTrendHtml));
      }

      detailsBodyEl.innerHTML = blocks.join("");
    }

    async function loadMarketDetails() {
      let symbol = "TSLA";
      const symbolRaw = symbolInput.value.trim().toUpperCase();
      if (symbolRaw) {
        symbol = symbolRaw;
      }
      detailsStatusEl.textContent = "Loading market details";
      try {
        const res = await fetch(`/api/fmp/market-details?symbol=${encodeURIComponent(symbol)}`);
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || "Failed to load market details");
        }
        renderMarketDetails(data);
        detailsUpdatedEl.textContent = "Updated now";
        detailsStatusEl.textContent = "Ready";
      } catch (err) {
        detailsStatusEl.textContent = err.message ? String(err.message) : "Failed to load market details";
      }
    }

    function renderLiveUpdated() {
      const seconds = Math.max(0, Math.floor((Date.now() - lastLiveUpdate) / 1000));
      liveUpdatedEl.textContent = `Updated ${seconds}s ago`;
    }

    async function loadListedSymbols() {
      const fallbackSymbols = ["TSLA", "AAPL", "MSFT"];
      try {
        const res = await fetch("/api/registry/listings");
        const data = await res.json();
        let listings = [];
        if (Array.isArray(data.listings)) {
          listings = data.listings;
        }
        symbolInput.innerHTML = "";
        if (!listings.length) {
          for (const symbol of fallbackSymbols) {
            const opt = document.createElement("option");
            opt.value = symbol;
            opt.textContent = symbol;
            symbolInput.appendChild(opt);
          }
        } else {
          for (const item of listings) {
            let symbolValue = "";
            if (item.symbol) {
              symbolValue = item.symbol;
            }
            const symbol = String(symbolValue).toUpperCase();
            if (!symbol) continue;
            const opt = document.createElement("option");
            opt.value = symbol;
            opt.textContent = symbol;
            symbolInput.appendChild(opt);
          }
        }
      } catch {
        symbolInput.innerHTML = "";
        for (const symbol of fallbackSymbols) {
          const opt = document.createElement("option");
          opt.value = symbol;
          opt.textContent = symbol;
          symbolInput.appendChild(opt);
        }
      }
      let selected = fallbackSymbols[0];
      const selectedRaw = symbolInput.value.trim().toUpperCase();
      if (selectedRaw) {
        selected = selectedRaw;
      }
      liveSymbol = selected;
      resetLivePriceState(selected);
      liveSymbolLabel.textContent = `${selected} live price`;
    }

    function setInfoText(el, value) {
      el.textContent = value;
    }

    async function loadStockInfo() {
      let symbol = "TSLA";
      const symbolRaw = symbolInput.value.trim().toUpperCase();
      if (symbolRaw) {
        symbol = symbolRaw;
      }
      try {
        const res = await fetch(
          `/api/fmp/stock-info?symbol=${encodeURIComponent(symbol)}`
        );
        const data = await res.json();
        latestStockInfo = data;
        setInfoText(infoPrevCloseEl, formatNullable(data.previousClose, formatPrice));
        setInfoText(infoOpenEl, formatNullable(data.open, formatPrice));
        setInfoText(infoDayRangeEl, formatRange(data.dayLow, data.dayHigh));
        setInfoText(infoYearRangeEl, formatRange(data.yearLow, data.yearHigh));
        setInfoText(infoVolumeEl, formatNullable(data.volume, formatInt));
        setInfoText(infoMarketCapEl, formatCompact(data.marketCap));
        const bidText = formatNullable(data.bid, formatPrice);
        const askText = formatNullable(data.ask, formatPrice);
        setInfoText(infoBidAskEl, `${bidText} / ${askText}`);
        let infoLabel = "Snapshot";
        if (data.stale) {
          infoLabel = "Snapshot (stale)";
        }
        infoUpdatedEl.textContent = infoLabel;
        liveOpenPrice = Number(data.open);
        liveOpenEl.textContent = formatNullable(liveOpenPrice, formatPrice);
      } catch (err) {
        infoUpdatedEl.textContent = "Updated -";
      }
    }

    function getETDateString() {
      const etNow = new Date(new Date().toLocaleString("en-US", { timeZone: "America/New_York" }));
      const y = etNow.getFullYear();
      const m = String(etNow.getMonth() + 1).padStart(2, "0");
      const d = String(etNow.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    const HOLIDAYS_ET = [
      "2025-01-01","2025-01-20","2025-02-17","2025-04-18","2025-05-26","2025-06-19","2025-07-04","2025-09-01","2025-11-27","2025-12-25",
      "2026-01-01","2026-01-19","2026-02-16","2026-04-03","2026-05-25","2026-06-19","2026-07-03","2026-09-07","2026-11-26","2026-12-25",
    ];

    let lastValidDate = getETDateString();
    let [startY, startM, startD] = lastValidDate.split("-").map(Number);
    let dt = new Date(Date.UTC(startY, startM - 1, startD));
    for (let i = 0; i < 10; i++) {
      dt.setUTCDate(dt.getUTCDate() - 1);
      const cur = dt.toISOString().slice(0, 10);
      const [y, m, d] = cur.split("-").map(Number);
      const weekday = new Date(Date.UTC(y, m - 1, d)).getUTCDay();
      const weekend = weekday === 0 || weekday === 6;
      const holiday = HOLIDAYS_ET.includes(cur);
      if (!weekend && !holiday) {
        lastValidDate = cur;
        break;
      }
    }
    dateInput.value = lastValidDate;

    flatpickr(dateInput, {
      dateFormat: "Y-m-d",
      defaultDate: lastValidDate,
      maxDate: getETDateString(),
      disable: [
        (date) => {
          const day = date.getDay();
          const isWeekend = day === 0 || day === 6;
          return isWeekend;
        },
        ...HOLIDAYS_ET,
      ],
      onChange: (selectedDates, dateStr) => {
        lastValidDate = dateStr;
        setStatus("Ready");
        loadCandles();
      },
    });

    const etFormatter = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      hour: "2-digit",
      minute: "2-digit",
      month: "2-digit",
      day: "2-digit",
    });

    const chart = LightweightCharts.createChart(chartEl, {
      layout: {
        background: { color: "transparent" },
        textColor: "#101418",
        fontFamily: "Space Grotesk, sans-serif",
      },
      grid: {
        vertLines: { color: "rgba(16, 20, 24, 0.08)" },
        horzLines: { color: "rgba(16, 20, 24, 0.08)" },
      },
      rightPriceScale: {
        borderVisible: false,
      },
      timeScale: {
        borderVisible: false,
        timeVisible: true,
        secondsVisible: false,
        tickMarkFormatter: (time) => {
          return etFormatter.format(new Date(time * 1000));
        },
      },
      localization: {
        timeFormatter: (time) => {
          return etFormatter.format(new Date(time * 1000));
        },
      },
    });

    const candleSeries = chart.addCandlestickSeries({
      upColor: "#1b8b8b",
      downColor: "#e04c4c",
      borderVisible: false,
      wickUpColor: "#1b8b8b",
      wickDownColor: "#e04c4c",
    });

    

    window.addEventListener("resize", () => {
      chart.applyOptions({ width: chartEl.clientWidth });
    });

    function resetLivePriceState(symbol) {
      liveSymbol = symbol;
      liveOpenPrice = 0;
      lastLiveUpdate = 0;
      latestStockInfo = {};
      livePriceEl.textContent = "-";
      liveChangeEl.textContent = "-";
      liveOpenEl.textContent = "-";
      renderLiveUpdated();
    }

    async function loadLivePrice() {
      let symbol = "TSLA";
      const symbolRaw = symbolInput.value.trim().toUpperCase();
      if (symbolRaw) {
        symbol = symbolRaw;
      }
      if (symbol !== liveSymbol) {
        resetLivePriceState(symbol);
      }

      liveSymbolLabel.textContent = `${symbol} live price`;

      try {
        const res = await fetch(
          `/api/fmp/quote-short?symbol=${encodeURIComponent(symbol)}`
        );
        const data = await res.json(
        );
        const currentPrice = Number(data.price);
        let previousClose = Number(data.previousClose);
        if (!(Number.isFinite(previousClose) && previousClose > 0)) {
          previousClose = Number(latestStockInfo.previousClose);
        }
        if (!(Number.isFinite(previousClose) && previousClose > 0)) {
          const infoRes = await fetch(`/api/fmp/stock-info?symbol=${encodeURIComponent(symbol)}`);
          const infoData = await infoRes.json();
          if (infoRes.ok && !infoData.error) {
            latestStockInfo = infoData;
            previousClose = Number(infoData.previousClose);
          }
        }
        let changeValue = 0;
        let changePct = 0;
        let hasChange = false;
        if (Number.isFinite(currentPrice) && currentPrice > 0 && Number.isFinite(previousClose) && previousClose > 0) {
          changeValue = Number((currentPrice - previousClose).toFixed(2));
          changePct = (currentPrice - previousClose) / previousClose;
          hasChange = true;
        } else {
          const quoteChangePercent = Number(data.changePercent);
          if (Number.isFinite(quoteChangePercent)) {
            changePct = quoteChangePercent;
            changeValue = currentPrice * quoteChangePercent;
            hasChange = true;
          }
        }

        livePriceEl.textContent = formatPrice(currentPrice);
        if (hasChange) {
          const pctValue = changePct * 100;
          if (pctValue > 0) {
            liveChangeEl.textContent = `+${pctValue.toFixed(2)}%`;
          } else {
            liveChangeEl.textContent = `${pctValue.toFixed(2)}%`;
          }
        } else {
          liveChangeEl.textContent = "-";
        }
        liveOpenEl.textContent = formatPrice(liveOpenPrice);

        let direction = 0;
        if (hasChange) {
          direction = changeValue;
        }
        applyChangeClass(liveChangeEl, direction);
        applyChangeClass(liveUpdatedEl, direction);

        lastLiveUpdate = Date.now();
        renderLiveUpdated();
      } catch (err) {
        applyChangeClass(liveChangeEl, 0);
        applyChangeClass(liveUpdatedEl, 0);
      }
    }

    function startLivePricePolling() {
      clearInterval(livePoller);
      clearInterval(liveTicker);
      if (!livePollingEnabled) {
        return;
      }
      livePoller = setInterval(loadLivePrice, 2000);
      liveTicker = setInterval(renderLiveUpdated, 1000);
    }

    async function loadCandles() {
      let symbol = "TSLA";
      const symbolRaw = symbolInput.value.trim().toUpperCase();
      if (symbolRaw) {
        symbol = symbolRaw;
      }
      const date = dateInput.value;
      const range = rangeInput.value;
      let interval = "5";
      if (range === "1d") {
        interval = "5";
      } else if (range === "5d") {
        interval = "360";
      } else if (range === "1m") {
        interval = "1440";
      } else if (range === "3m") {
        interval = "1440";
      } else if (range === "6m") {
        interval = "17280";
      }

      setStatus("loading candles");

      try {
        const res = await fetch(
          `/api/candles?symbol=${encodeURIComponent(symbol)}&date=${date}&interval=${interval}&range=${range}`
        );
        const data = await res.json(
        );
        const candleData = data.candles.map((c) => {
          return {
            time: c.timeSec,
            open: c.open,
            high: c.high,
            low: c.low,
            close: c.close,
          };
        });

        candleSeries.setData(candleData);
        chart.timeScale().fitContent();

        const qfData = data.candles.map((c) => {
          const parts = new Intl.DateTimeFormat("en-US", {
            timeZone: "America/New_York",
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            hour12: false,
          }).formatToParts(new Date(c.timeSec * 1000));

          function getPartValue(type) {
            for (let i = 0; i < parts.length; i++) {
              const part = parts[i];
              if (part.type === type) {
                return part.value;
              }
            }
            return "";
          }

          const time = Date.UTC(
            Number(getPartValue("year")),
            Number(getPartValue("month")) - 1,
            Number(getPartValue("day")),
            Number(getPartValue("hour")),
            Number(getPartValue("minute")),
            Number(getPartValue("second"))
          );

          return {
            time: time,
            open: c.open,
            high: c.high,
            low: c.low,
            close: c.close,
            volume: c.volume,
          };
        });
        
        
        let rangeLabel = "1 trading day";
        if (data.range === "5d") {
          rangeLabel = "5 trading days";
        } else if (data.range === "1m") {
          rangeLabel = "1 month (trading days)";
        } else if (data.range === "3m") {
          rangeLabel = "3 months (trading days)";
        } else if (data.range === "6m") {
          rangeLabel = "6 months (trading days)";
        }
        setStatus(`Loaded ${data.candles.length} candles for ${data.symbol} (${rangeLabel} ending ${data.date}).`);
      } catch (err) {
        setStatus(err.message, "error");
      }
    }

    symbolInput.addEventListener("change", () => {
      setStatus("Ready");
      resetLivePriceState(symbolInput.value.trim().toUpperCase() || "TSLA");
      loadLivePrice();
      loadStockInfo();
      loadMarketDetails();
      loadCandles();
    });

    rangeInput.addEventListener("change", () => {
      setStatus("Ready");
      loadCandles();
    });

    (async function init() {
      await loadListedSymbols();
      await loadStockInfo();
      await loadMarketDetails();
      await loadCandles();
      applyLiveUpdatesState(true);
    })();
    
    function applyLiveUpdatesState(enabled) {
      livePollingEnabled = enabled;
      if (enabled) {
        loadLivePrice();
        startLivePricePolling();
        return;
      }
      clearInterval(livePoller);
      clearInterval(liveTicker);
    }

    window.addEventListener("message", (event) => {
      const payload = event.data;
      if (payload.type === "LIVE_UPDATES") {
        applyLiveUpdatesState(payload.enabled);
      }
    });
    
  </script>
</body>
</html>
