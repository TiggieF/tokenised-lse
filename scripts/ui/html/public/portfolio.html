<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Portfolio</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --ink: #101418;
      --muted: #5b6b7a;
      --accent: #e04c4c;
      --accent-2: #1b8b8b;
      --panel: rgba(255, 255, 255, 0.85);
      --shadow: rgba(16, 20, 24, 0.12);
      --bg-1: #f6f0e6;
      --bg-2: #dfe7ef;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Space Grotesk", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(1200px 600px at 10% 0%, #fef6d8 0%, transparent 60%),
        radial-gradient(900px 500px at 90% 10%, #d5f2ff 0%, transparent 55%),
        linear-gradient(180deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
      padding: 32px;
    }

    .panel {
      background: var(--panel);
      border-radius: 18px;
      box-shadow: 0 12px 30px var(--shadow);
      padding: 24px;
      backdrop-filter: blur(8px);
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 16px;
    }

    .title {
      font-size: 22px;
      font-weight: 600;
      margin: 0;
    }

    .wallet {
      color: var(--muted);
      font-size: 12px;
      word-break: break-all;
      margin-top: 4px;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      margin-bottom: 18px;
    }

    .summary-card {
      padding: 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.75);
      border: 1px solid rgba(16, 20, 24, 0.08);
    }

    .summary-label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 4px;
    }

    .summary-value {
      font-size: 18px;
      font-weight: 600;
    }

    .section-header {
      margin-top: 24px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .section-title {
      font-size: 16px;
      font-weight: 600;
      margin: 0;
      color: var(--muted);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .status {
      font-size: 12px;
      color: var(--muted);
    }
    .status-ok {
      color: var(--accent-2);
    }
    .status-warn {
      color: var(--accent);
      font-weight: 600;
    }
    .market-alert {
      margin-top: 10px;
      margin-bottom: 6px;
      padding: 12px 14px;
      border-radius: 10px;
      background: rgba(224, 76, 76, 0.12);
      color: var(--accent);
      font-weight: 700;
      border: 1px solid rgba(224, 76, 76, 0.35);
      font-size: 13px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 14px;
      overflow: hidden;
    }

    thead th {
      text-align: left;
      padding: 10px 12px;
      font-size: 11px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--muted);
      border-bottom: 1px solid rgba(16, 20, 24, 0.08);
    }

    tbody td {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(16, 20, 24, 0.06);
      vertical-align: top;
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    .gain { font-weight: 600; }
    .gain.positive { color: var(--accent-2); }
    .gain.negative { color: var(--accent); }
    .gain.neutral { color: var(--muted); }

    .claim-btn {
      border: none;
      border-radius: 10px;
      padding: 7px 10px;
      background: var(--accent-2);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      font-size: 12px;
    }

    .sell-btn {
      border: none;
      border-radius: 10px;
      padding: 7px 10px;
      background: var(--accent);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      font-size: 12px;
    }

    .action-stack {
      display: grid;
      gap: 6px;
      min-width: 130px;
    }

    .action-stack input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(16, 20, 24, 0.12);
      font-family: inherit;
      font-size: 12px;
      background: #fff;
    }

    .muted { color: var(--muted); }

    @media (max-width: 780px) {
      body { padding: 20px; }
      table { display: block; overflow-x: auto; }
    }
  </style>
</head>
<body>
  <div class="panel">
    <div class="header">
      <div>
        <h1 class="title">Portfolio</h1>
        <div id="wallet" class="wallet">Wallet: -</div>
      </div>
      <button id="refresh-btn" class="claim-btn" type="button">Refresh</button>
    </div>

    <div class="summary-grid" id="summary-grid"></div>
    <div id="market-alert" class="market-alert" style="display:none"></div>

    <div class="section-header">
      <h2 class="section-title">Holdings</h2>
      <div id="holdings-status" class="status">Loading</div>
    </div>
    <table>
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Quantity</th>
          <th>Avg Cost</th>
          <th>Current</th>
          <th>Cost Basis</th>
          <th>Market Value</th>
          <th>P/L %</th>
        </tr>
      </thead>
      <tbody id="positions-body"></tbody>
    </table>

    <div class="section-header">
      <h2 class="section-title">Claimable Dividends</h2>
      <div id="dividends-status" class="status">Ready</div>
    </div>
    <table>
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Claimable (TToken)</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody id="dividends-body"></tbody>
    </table>

    <div class="section-header">
      <h2 class="section-title">Leveraged Tokens</h2>
      <div id="leveraged-status" class="status">Ready</div>
    </div>
    <table>
      <thead>
        <tr>
          <th>Product</th>
          <th>Live Price</th>
          <th>% Change vs Avg</th>
          <th>Avg Entry (value of one unit)</th>
          <th>Current Value</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody id="leveraged-body"></tbody>
    </table>
  </div>

  <script>
    const walletEl = document.getElementById("wallet");
    const summaryGrid = document.getElementById("summary-grid");
    const positionsBody = document.getElementById("positions-body");
    const dividendsBody = document.getElementById("dividends-body");
    const holdingsStatus = document.getElementById("holdings-status");
    const dividendsStatus = document.getElementById("dividends-status");
    const leveragedStatus = document.getElementById("leveraged-status");
    const marketAlert = document.getElementById("market-alert");
    const refreshBtn = document.getElementById("refresh-btn");
    const leveragedBody = document.getElementById("leveraged-body");
    let lifecycleBySymbol = {};

    let currentWallet = "";
    let pollingEnabled = false;
    let poller;
    const SEPOLIA_CHAIN_ID_HEX = "0xaa36a7";

    async function ensureSepoliaNetwork() {
      const chainId = String(await window.ethereum.request({ method: "eth_chainId" })).toLowerCase();
      if (chainId === SEPOLIA_CHAIN_ID_HEX) {
        return;
      }
      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: SEPOLIA_CHAIN_ID_HEX }],
        });
      } catch (err) {
        throw new Error("Please switch MetaMask network to Sepolia");
      }
      const after = String(await window.ethereum.request({ method: "eth_chainId" })).toLowerCase();
      if (after !== SEPOLIA_CHAIN_ID_HEX) {
        throw new Error("MetaMask network is not Sepolia");
      }
    }

    function isValidWalletAddress(value) {
      if (!value) {
        return false;
      }
      const text = String(value).trim();
      const re = /^0x[a-fA-F0-9]{40}$/;
      return re.test(text);
    }

    function chooseDisplayAccount(rawAccounts) {
      let accounts = [];
      if (Array.isArray(rawAccounts)) {
        accounts = rawAccounts;
      }
      let selectedAddress = "";
      if (window.ethereum && window.ethereum.selectedAddress) {
        selectedAddress = String(window.ethereum.selectedAddress);
      }
      if (selectedAddress) {
        const selectedLower = selectedAddress.toLowerCase();
        for (let i = 0; i < accounts.length; i += 1) {
          const account = String(accounts[i]);
          if (account.toLowerCase() === selectedLower) {
            if (isValidWalletAddress(account)) {
              return account;
            }
          }
        }
      }
      if (accounts.length > 0) {
        const first = String(accounts[0]);
        if (isValidWalletAddress(first)) {
          return first;
        }
      }
      return "";
    }

    async function waitForWalletReceipt(txHash) {
      for (let i = 0; i < 120; i += 1) {
        const receipt = await window.ethereum.request({
          method: "eth_getTransactionReceipt",
          params: [txHash],
        });
        if (receipt) {
          return receipt;
        }
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
      throw new Error(`tx not mined yet: ${txHash}`);
    }

    async function submitPreparedTxs(txs) {
      if (!Array.isArray(txs) || txs.length === 0) {
        throw new Error("No transactions prepared");
      }
      await ensureSepoliaNetwork();
      let lastTxHash = "";
      for (let i = 0; i < txs.length; i += 1) {
        const tx = txs[i];
        const txParams = {
          from: currentWallet,
          to: tx.to,
          data: tx.data,
          chainId: SEPOLIA_CHAIN_ID_HEX,
        };
        const txHash = await window.ethereum.request({
          method: "eth_sendTransaction",
          params: [txParams],
        });
        await waitForWalletReceipt(txHash);
        lastTxHash = txHash;
      }
      return lastTxHash;
    }

    function formatWeiToToken(valueWei, digits = 4) {
      const num = Number(valueWei) / 1e18;
      return num.toFixed(digits);
    }

    function formatUsdFromWei(valueWei) {
      const num = Number(valueWei) / 1e18;
      return `$${num.toFixed(2)}`;
    }

    function formatUsdFromWeiExact(valueWei) {
      let wei = BigInt(String(valueWei));
      let negative = false;
      if (wei < 0n) {
        negative = true;
        wei = -wei;
      }
      const dollars = wei / 1000000000000000000n;
      const cents = (wei % 1000000000000000000n) / 10000000000000000n;
      const centsText = String(cents).padStart(2, "0");
      let text = `$${dollars.toString()}.${centsText}`;
      if (negative) {
        text = `-${text}`;
      }
      return text;
    }

    function formatCents(cents) {
      const raw = Number(cents);
      if (!Number.isFinite(raw) || raw <= 0) {
        return "-";
      }
      const num = raw / 100;
      return `$${num.toFixed(2)}`;
    }

    function formatEthFromWei(valueWei) {
      const num = Number(valueWei) / 1e18;
      if (!Number.isFinite(num) || num < 0) {
        return "0.000000 ETH";
      }
      return `${num.toFixed(6)} ETH`;
    }

    function renderSummary(summary) {
      const totalValueWei = BigInt(String(summary.totalValueWei));
      const totalCostBasisWei = BigInt(String(summary.totalCostBasisWei));
      const profitWei = totalValueWei - totalCostBasisWei;
      const nativeSymbol = summary.nativeSymbol ? String(summary.nativeSymbol) : "SepoliaETH";
      const nativeEthWei = summary.nativeEthWei ? summary.nativeEthWei : "0";
      const cards = [
        ["Cash", formatUsdFromWei(summary.cashValueWei)],
        ["Stock Value", formatUsdFromWei(summary.stockValueWei)],
        ["Leveraged Value", formatUsdFromWei(summary.leveragedValueWei)],
        ["Total Value", formatUsdFromWei(summary.totalValueWei)],
        ["Cost Basis", formatUsdFromWei(summary.totalCostBasisWei)],
        ["Overall Gas Used", formatEthFromWei(summary.overallGasCostWei)],
        [nativeSymbol, formatEthFromWei(nativeEthWei)],
        // ["Profit", formatUsdFromWeiExact(profitWei.toString())],
      ];
      summaryGrid.innerHTML = "";
      for (const [label, value] of cards) {
        const card = document.createElement("div");
        card.className = "summary-card";
        card.innerHTML = `<div class="summary-label">${label}</div><div class="summary-value">${value}</div>`;
        summaryGrid.appendChild(card);
      }
    }

    function renderPositions(positions) {
      positionsBody.innerHTML = "";
      if (!positions.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = '<td colspan="7" class="muted">No holdings yet</td>';
        positionsBody.appendChild(tr);
        return;
      }

      for (const p of positions) {
        const lifecycleRow = lifecycleBySymbol[String(p.symbol).toUpperCase()];
        let lifecycle = "ACTIVE";
        if (lifecycleRow && lifecycleRow.status) {
          lifecycle = String(lifecycleRow.status).toUpperCase();
        }
        const isTradable = lifecycle === "ACTIVE";
        let pnlPct = Number(p.unrealizedPnlPct);
        if (!Number.isFinite(pnlPct)) {
          const cost = Number(p.costBasisWei);
          const value = Number(p.currentValueWei);
          if (Number.isFinite(cost) && cost > 0 && Number.isFinite(value)) {
            pnlPct = ((value - cost) / cost) * 100;
          }
        }
        let pnlClass = "gain neutral";
        let pnlText = "-";
        if (Number.isFinite(pnlPct)) {
          if (pnlPct > 0) {
            pnlClass = "gain positive";
            pnlText = `+${pnlPct.toFixed(2)}%`;
          } else if (pnlPct < 0) {
            pnlClass = "gain negative";
            pnlText = `${pnlPct.toFixed(2)}%`;
          } else {
            pnlClass = "gain neutral";
            pnlText = "0.00%";
          }
        }
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${p.symbol}</td>
          <td>${formatWeiToToken(p.balanceWei, 2)}</td>
          <td>${formatCents(p.avgCostCents)}</td>
          <td>${formatCents(p.priceCents)}</td>
          <td>${formatUsdFromWei(p.costBasisWei)}</td>
          <td>${formatUsdFromWei(p.currentValueWei)}</td>
          <td class="${pnlClass}">${pnlText}</td>
        `;
        if (isTradable) {
          tr.style.cursor = "pointer";
          tr.addEventListener("click", () => {
            window.location.href = `/sell.html?symbol=${encodeURIComponent(p.symbol)}`;
          });
        } else {
          tr.style.opacity = "0.75";
          tr.title = `${p.symbol} is ${lifecycle} by admin and cannot be traded`;
        }
        positionsBody.appendChild(tr);
      }
    }

    function renderMarketAlert(positions) {
      const blockedSymbols = [];
      for (let i = 0; i < positions.length; i += 1) {
        const p = positions[i];
        const lifecycleRow = lifecycleBySymbol[String(p.symbol).toUpperCase()];
        let lifecycle = "ACTIVE";
        if (lifecycleRow && lifecycleRow.status) {
          lifecycle = String(lifecycleRow.status).toUpperCase();
        }
        if (lifecycle === "FROZEN" || lifecycle === "DELISTED") {
          blockedSymbols.push(`${p.symbol} (${lifecycle})`);
        }
      }
      if (blockedSymbols.length > 0) {
        marketAlert.style.display = "block";
        marketAlert.textContent = `Trading is blocked by admin for: ${blockedSymbols.join(", ")}`;
      } else {
        marketAlert.style.display = "none";
        marketAlert.textContent = "";
      }
    }

    async function claimDividend(row) {
      try {
        const symbol = String(row.symbol).toUpperCase();
        let claimType = String(row.claimType).toUpperCase();
        if (!claimType) {
          claimType = "SNAPSHOT";
        }
        dividendsStatus.textContent = `Claiming ${symbol} dividend`;
        let res;
        if (claimType === "MERKLE") {
          res = await fetch("/api/dividends/merkle/claim", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              clientSign: true,
              wallet: currentWallet,
              account: currentWallet,
              epochId: row.epochId,
              amountWei: row.amountWei,
              leafIndex: row.leafIndex,
              proof: row.proof,
            }),
          });
        } else {
          res = await fetch("/api/dividends/claim", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ clientSign: true, wallet: currentWallet, symbol, epochId: row.epochId }),
          });
        }
        const data = await res.json();
        let failed = false;
        if (!res.ok) {
          failed = true;
        }
        if (data.error) {
          failed = true;
        }
        if (failed) {
          throw new Error(String(data.error));
        }
        let txHash = data.txHash;
        if (data.clientSign && Array.isArray(data.txs)) {
          txHash = await submitPreparedTxs(data.txs);
        }
        dividendsStatus.textContent = `Claimed ${symbol}. Tx: ${txHash}`;
        await refreshPortfolio();
      } catch (err) {
        dividendsStatus.textContent = err.message;
      }
    }

    function renderClaimables(claimables) {
      dividendsBody.innerHTML = "";
      if (!claimables.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = '<td colspan="3" class="muted">No dividends yet</td>';
        dividendsBody.appendChild(tr);
        return;
      }

      let shown = 0;
      for (const row of claimables) {
        if (!row.canClaim && !row.claimed) {
          continue;
        }
        if (!row.canClaim) continue;
        shown += 1;
        const tr = document.createElement("tr");
        const actionTd = document.createElement("td");
        if (row.canClaim) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "claim-btn";
          btn.textContent = "Claim";
          btn.addEventListener("click", () => claimDividend(row));
          actionTd.appendChild(btn);
        } else if (row.claimed) {
          actionTd.textContent = "Claimed";
          actionTd.className = "muted";
        } else {
          actionTd.textContent = "-";
          actionTd.className = "muted";
        }

        let merkleTag = "";
        if (row.claimType === "MERKLE") {
          merkleTag = "(M)";
        }
        tr.innerHTML = `
          <td>${row.symbol} ${merkleTag}</td>
          <td>${formatWeiToToken(row.claimableWei, 2)}</td>
        `;
        tr.appendChild(actionTd);
        dividendsBody.appendChild(tr);
      }

      if (shown === 0) {
        const tr = document.createElement("tr");
        tr.innerHTML = '<td colspan="3" class="muted">No claimable dividends right now</td>';
        dividendsBody.appendChild(tr);
      }
    }

    async function sellLeveragedPosition(productSymbol, qtyWei) {
      try {
        if (!currentWallet) {
          leveragedStatus.textContent = "Wallet not connected";
          return;
        }
        const qtyNumber = Number(qtyWei);
        if (!(qtyNumber > 0)) {
          leveragedStatus.textContent = "qty must be greater than 0";
          return;
        }
        leveragedStatus.textContent = `Selling ${productSymbol}`;
        const res = await fetch("/api/leveraged/unwind", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            clientSign: true,
            wallet: currentWallet,
            productSymbol: productSymbol,
            qtyWei: qtyWei,
            minOutWei: "0",
          }),
        });
        const data = await res.json();
        let failed = false;
        if (!res.ok) {
          failed = true;
        }
        if (data.error) {
          failed = true;
        }
        if (failed) {
          let message = "Sell failed";
          if (data.error) {
            message = data.error;
          }
          throw new Error(message);
        }
        let txHash = data.txHash;
        if (data.clientSign && Array.isArray(data.txs)) {
          txHash = await submitPreparedTxs(data.txs);
        }
        leveragedStatus.textContent = `Sold ${productSymbol} Tx: ${txHash}`;
        await refreshPortfolio();
      } catch (err) {
        let message = "Sell failed";
        if (err.message) {
          message = err.message;
        }
        leveragedStatus.textContent = message;
      }
    }

    function renderLeveragedPositions(items) {
      leveragedBody.innerHTML = "";
      if (!items.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = '<td colspan="6" class="muted">Nothing here yet</td>';
        leveragedBody.appendChild(tr);
        return;
      }
      for (const item of items) {
        const tr = document.createElement("tr");
        const actionTd = document.createElement("td");
        const actionWrap = document.createElement("div");
        actionWrap.className = "action-stack";

        const sellBtn = document.createElement("button");
        sellBtn.type = "button";
        sellBtn.className = "sell-btn";
        sellBtn.textContent = "Sell";
        sellBtn.addEventListener("click", async () => {
          try {
            await sellLeveragedPosition(item.productSymbol, item.qtyWei);
          } catch (err) {
            let message = "Sell failed";
            if (err.message) {
              message = err.message;
            }
            leveragedStatus.textContent = message;
          }
        });

        actionWrap.appendChild(sellBtn);
        actionTd.appendChild(actionWrap);
        const leverage = Number(item.leverage);
        let livePriceCents = Number(item.navCents);
        const baseLivePriceCents = Number(item.basePriceCents);
        if (Number.isFinite(baseLivePriceCents) && baseLivePriceCents > 0) {
          livePriceCents = baseLivePriceCents;
        }
        let changePct = null;
        const livePrice = Number(livePriceCents) / 100;
        const avgEntry = Number(item.avgEntryPriceCents) / 100;
        if (
          Number.isFinite(livePrice)
          && livePrice > 0
          && Number.isFinite(avgEntry)
          && avgEntry > 0
          && Number.isFinite(leverage)
          && leverage > 0
        ) {
          changePct = (((livePrice - avgEntry) / avgEntry) * leverage) * 100;
        } else {
          const baseChangeRaw = item.baseChangePct;
          const baseChangePct = (typeof baseChangeRaw === "number" && Number.isFinite(baseChangeRaw))
            ? baseChangeRaw
            : NaN;
          if (Number.isFinite(baseChangePct)) {
            if (Number.isFinite(leverage) && leverage > 0) {
              changePct = baseChangePct * leverage;
            } else {
              changePct = baseChangePct;
            }
          }
        }
        let changeClass = "gain neutral";
        let changeText = "-";
        if (Number.isFinite(changePct)) {
          if (changePct > 0) {
            changeClass = "gain positive";
            changeText = `+${changePct.toFixed(2)}%`;
          } else if (changePct < 0) {
            changeClass = "gain negative";
            changeText = `${changePct.toFixed(2)}%`;
          } else {
            changeClass = "gain neutral";
            changeText = "0.00%";
          }
        }
        tr.innerHTML = `
          <td>${item.productSymbol}</td>
          <td>${formatCents(livePriceCents)}</td>
          <td class="${changeClass}">${changeText}</td>
          <td>${formatCents(item.avgEntryPriceCents)}</td>
          <td>${formatUsdFromWei(item.currentValueWei)}</td>
        `;
        tr.appendChild(actionTd);
        leveragedBody.appendChild(tr);
      }
    }

    async function fetchJsonWithTimeout(url, timeoutMs = 8000) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const res = await fetch(url, { signal: controller.signal });
        const data = await res.json();
        return { res, data };
      } finally {
        clearTimeout(timer);
      }
    }

    async function refreshPortfolio() {
      if (!isValidWalletAddress(currentWallet)) {
        holdingsStatus.textContent = "Wallet not connected";
        return;
      }
      try {
        await ensureSepoliaNetwork();
      } catch (err) {
        holdingsStatus.textContent = err.message ? String(err.message) : "Please switch to Sepolia";
        return;
      }
      holdingsStatus.textContent = "Loading";
      const results = await Promise.allSettled([
        fetchJsonWithTimeout(`/api/portfolio/summary?wallet=${encodeURIComponent(currentWallet)}`),
        fetchJsonWithTimeout(`/api/portfolio/positions?wallet=${encodeURIComponent(currentWallet)}`),
        fetchJsonWithTimeout(`/api/dividends/claimables?wallet=${encodeURIComponent(currentWallet)}`),
        fetchJsonWithTimeout(`/api/leveraged/positions?wallet=${encodeURIComponent(currentWallet)}`),
        fetchJsonWithTimeout("/api/admin/symbols/status"),
      ]);

      let summaryData = null;
      let positionsData = null;
      let claimablesData = null;
      let leveragedData = null;
      let lifecycleData = null;

      if (results[0].status === "fulfilled") {
        summaryData = results[0].value.data;
      }
      if (results[1].status === "fulfilled") {
        positionsData = results[1].value.data;
      }
      if (results[2].status === "fulfilled") {
        claimablesData = results[2].value.data;
      }
      if (results[3].status === "fulfilled") {
        leveragedData = results[3].value.data;
      }
      if (results[4].status === "fulfilled") {
        lifecycleData = results[4].value.data;
      }

      let lifecycleRows = [];
      if (lifecycleData && Array.isArray(lifecycleData.symbols)) {
        lifecycleRows = lifecycleData.symbols;
      }
      lifecycleBySymbol = {};
      for (let i = 0; i < lifecycleRows.length; i += 1) {
        const row = lifecycleRows[i];
        lifecycleBySymbol[String(row.symbol).toUpperCase()] = row;
      }

      let summaryOk = false;
      if (summaryData && !summaryData.error) {
        summaryOk = true;
      }
      let positionsOk = false;
      if (positionsData && !positionsData.error && Array.isArray(positionsData.positions)) {
        positionsOk = true;
      }
      if (summaryOk) {
        renderSummary(summaryData);
      }
      if (positionsOk) {
        renderPositions(positionsData.positions);
        renderMarketAlert(positionsData.positions);
      }
      if (summaryOk && positionsOk) {
        holdingsStatus.textContent = "";
      } else {
        holdingsStatus.textContent = "Partial data loaded (RPC/indexer still syncing)";
      }

      let claimablesOk = false;
      if (claimablesData && !claimablesData.error && Array.isArray(claimablesData.claimables)) {
        claimablesOk = true;
      }
      if (claimablesOk) {
        renderClaimables(claimablesData.claimables);
        dividendsStatus.textContent = "Ready";
      } else {
        renderClaimables([]);
        dividendsStatus.textContent = "Slow / unavailable right now";
      }

      let leveragedOk = false;
      if (leveragedData && !leveragedData.error && Array.isArray(leveragedData.positions)) {
        leveragedOk = true;
      }
      if (leveragedOk) {
        renderLeveragedPositions(leveragedData.positions);
        leveragedStatus.textContent = "Ready";
      } else {
        renderLeveragedPositions([]);
        leveragedStatus.textContent = "Slow / unavailable right now";
      }
    }

    function setPolling(enabled) {
      pollingEnabled = enabled;
      if (poller) {
        clearInterval(poller);
      }
      if (enabled) {
        refreshPortfolio();
        poller = setInterval(refreshPortfolio, 10000);
      }
    }

    refreshBtn.addEventListener("click", refreshPortfolio);

    window.ethereum.on("accountsChanged", function (accounts) {
      currentWallet = chooseDisplayAccount(accounts);
      walletEl.textContent = `Wallet: ${currentWallet}`;
      refreshPortfolio();
    });
    window.ethereum.on("chainChanged", function () {
      refreshPortfolio();
    });

    (async function init() {
      await ensureSepoliaNetwork();
      const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
      currentWallet = chooseDisplayAccount(accounts);
      walletEl.textContent = `Wallet: ${currentWallet}`;
      try {
        const lifecycleRes = await fetch("/api/admin/symbols/status");
        const lifecycleData = await lifecycleRes.json();
        let rows = [];
        if (Array.isArray(lifecycleData.symbols)) {
          rows = lifecycleData.symbols;
        }
        lifecycleBySymbol = {};
        for (let i = 0; i < rows.length; i += 1) {
          const row = rows[i];
          lifecycleBySymbol[String(row.symbol).toUpperCase()] = row;
        }
      } catch {
        lifecycleBySymbol = {};
      }
      await refreshPortfolio();
      setPolling(pollingEnabled);
    })();

    window.addEventListener("message", (event) => {
      const payload = event.data;
      if (payload.type === "LIVE_UPDATES") {
        setPolling(payload.enabled);
      }
    });
  </script>
</body>
</html>
